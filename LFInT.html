<h1> LFInT Writeup </h1>

    <p>
    This whole project started out as a ctf on vulnhub.com. Initially, I was doing it for the red team,<br>
    which had decided every week we needed a new vulnhub finished. No biggie so far, had two under my belt.<br>
    This one was different though. I was reading through several walkthroughs and gathering information on <br>
    how local file inclusion vulnerabilities worked. I had recalled several months ago I had stumbled upon<br>
    a writeup on someone who wrote a shell that was able to interface with a file listing script stuck<br>
    on a website. This gave me the idea to create a shell which would interface with the file inclusion,<br>
    effectively giving a full shell, going off the basis that you could read a certain file, and run commands<br>
    which would be printed to that file.
    </p>

    <p>
    The vm which I developed LFInT on is called evilscience, and can be downloaded <a href="https://www.vulnhub.com/entry/the-ether-evilscience-v101,212/">here</a><br>
    You open the vm, and find it to be headless.<br>
    </p>

    <img src="images/headless.jpg">

    <p>
    You run a simple nmap scan on this and find some interesting ports open:<br>
    </p>

    <img src="images/nmap.jpg">

    <p>
    Ok, there are decent ports open, but before exploring this, since it is<br>
    hosting on port 80, lets just imediately throw a vulnerability scan at it.<br>
    As it turns out, there is a possibility of local file inclusions, as hinted<br>
    by this scan result:<br>
    </p>

    <img src="images/vegascan.jpg">

    <p>
    Next thing, knowing that it might let me see files, is to try to find other<br>
    files which are included. Looking through common files included, something catches<br>
    my eye. /var/log/auth.log is a commonly included file, and our target is running ssh.<br>
    so try to curl this file:
    </p>

    <img src="images/curl_auth.jpg">

    <p>
    Ok, cool. Now I can read where the logs for authentication over ssh goes. But heres<br>
    the thing: Its in HTML thanks to curl. From past experience, I know with some easy<br>
    one line php, you can insert a line, for instance, <br>

    <br><code>&lt;?php echo system($_GET['cmd']); ?&gt;</code><br>

    <br>and execute commands on the server. So, why dont I try to use this as my username<br>
    for ssh, and curl the page giving it a command?<br>
    </p>

    <img src="images/php_as_username.jpg">

    <p>
    Now curl:
    </p>

    <img src="images/curl_command.jpg">

    <p>
    We have success! Now, this is where I stopped in the CTF challange. The reason being<br>
    I immediately started thinking of writing a script which doulc allow me to do so much with<br>
    this remote code execution vulnerability. After this point in the challenge, you would typically<br>
    run some sort of reverse shell, and get the flags to finish. Honestly, at thsi point, I still<br>
    have not finished the challenge. But, out of it, has come this script.<br><br> 
    </p>

    <p>
    To begin, I started with simple execution through python, specifically using os.system.<br>
    Before you laugh and say I dont know how to write python using os.system, just know <br>
    that this whole journey has brought me uppon better ways. Here is an example of how<br>
    I was curling the website through python at first:<br>
  
    <br><code>os.system("curl '192.168.150.128/index.php?file=/var/log/auth.log&amp;" + cmd)</code><br>

    </p>

    

    <p> 
    Next, I parsed through the files using some very bad file read/write operations.<br>
    Using sed and awk, it writes to a file, uses sed to clean up stuff which was specific<br>
    to this vm, then uses awk to clean up repeated lines. <br>
    </p>

    <img src="images/sed.jpg">

    <p>
    Through time though, I decided to make it more like a script, and implement libraries.<br>
    The first library which came in handy ws the pycurl library. Logically, this is the<br>
    best library to use in this case, as it performs the same operation as curl. Ofcourse <br>
    import StringIO for writing and reading the bytes of the curl. This allows for <br>
    my curl opperations to be done quite cleanly.<br>
    </p>

    <img src="images/pycurl.jpg">

    <p>
    The next steps are quite simple, create some methods to get a working directory, <br>
    in the main method include directory traversal, and execute.<br>
    </p>
    
    <img src="images/pwd.jpg"><br>
    <br><img src="images/main_method.jpg"><br>
    <br><img src="images/run.jpg"><br>

    <p>
    The only step left is to parse the information given to us, and have it printed out <br>
    to the terminal for a basic shell.<br>
    <p>
  
    <img src="images/shell.jpg">


    <p>
    This shell is still in development, but is on my <a href="https://github.com/rt-andr01d/LFInT">github</a><br>
    </p>
